// weaves

/ Regular expression matching - requires egex.so

\d .regex

i.lib:`$"@pkglibdir@/libqregex"

/ Regular expression match: 1st string pattern, 2nd string
/ Returns boolean
m: .regex.i.lib 2:(`q_match;2)
m1: .regex.i.lib 2:(`q_match1;3)

/ Regular expression match: 1st string pattern, 2nd string
/ Returns integer pair (first, last)
mark: .regex.i.lib 2:(`q_re_location;2)

/ Regular expression match: 1st string pattern, 2nd string, 3rd 1 for case-insensitive
/ Returns integer pair (first, last)
mark1: .regex.i.lib 2:(`q_re_location1;3)

.i.space: .regex.i.lib 2:(`q_re_despace;2)
.i.punct: .regex.i.lib 2:(`q_re_depunct;2)

// Removes all punctuation marks.
punct: .i.punct[;1]

// Reduces multiple spaces to just one.
space: .i.space[;1]

// Removes all spaces.
space0: { [x] x[where not x in " "] }

clean: { [x] .regex.space .regex.punct x }
clean1: { [x] .regex.space0 .regex.space .regex.punct x }

elide0: { [x;y] a:(" " vs x); b:{ $[ x ~ y;"";x] }[;y] each a; .regex.space (" " sv b) }

\d .

/ TODO - Convert to a symbol, dropping punctuation

/ atom
.regex.sym0: { [x] .regex.space .regex.punct (string x) }
/ list or atom
.regex.sym: { [x]
	     if[ 0 > type x; : .regex.sym0[x]]; 
	     if[ 10 = type x; : .regex.sym0[`$x]];
	     .regex.sym0 each x
	     }

/ These take a dictionary as third argument
/ icase ignore case
/ least use least number of characters
/ wreplace weight replace to double

.smet.lev.d: .regex.i.lib 2:(`q_lev_dist;3)
.smet.lev.r: .regex.i.lib 2:(`q_lev_ratio;3)

/ wreplace should not be used.
/ The fourth argument is the weight to give to prefix
.smet.jrw.r: .regex.i.lib 2:(`q_lev_jaro_winkler_ratio;4)

// Cyclic redundancy checks

\d .crc

i.lib:.regex.i.lib

// Basic string based.
// @return long unsigned integer
i.str:.crc.i.lib 2:(`q_crc32;1)

// String encoded
// @return string
str2str: { .Q.x10 .crc.i.str[ lower .regex.space0 .regex.space .regex.punct x ] }

\d



